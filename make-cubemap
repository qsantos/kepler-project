#!/usr/bin/env python3
"""Transform an equirectangular texture into a cubemap texture

Using OpenGL conventions (z = up):

z = r sin θ cos φ
x = r sin θ sin φ
y = r cos θ

Then r = y / cos θ, so:
(1) z = y tan θ cos φ
(2) x = y tan θ sin φ

By dividing (1) by (2), we obtain φ = atan2(x, z).

By summing (1) squared and (2) squared, we get θ = atan(sqrt(z*z + x*x) / y).
"""

from argparse import ArgumentParser, FileType
from math import atan2, hypot, pi

from PIL import Image


Image.MAX_IMAGE_PIXELS = 256 * 1024**2

parser = ArgumentParser()
parser.add_argument('image', type=FileType('rb'))
parser.add_argument('size', type=int)
args = parser.parse_args()

input_ = Image.open(args.image)
s = args.size
output = Image.new(input_.mode, (s, s))
s //= 2

o = output.load()
i = input_.load()

# +X
for z in range(-s, s):
    for y in range(-s, s):
        x = -s
        φ = atan2(z, x)
        θ = atan2(hypot(z, x), y)
        u = φ / (2 * pi) * input_.size[0]
        v = θ / pi * input_.size[1]
        o[s - 1 - z, s - 1 - y] = i[u, v]
output.save('PositiveX.jpg')

# -X
for z in range(-s, s):
    for y in range(-s, s):
        x = +s
        φ = atan2(z, x)
        θ = atan2(hypot(z, x), y)
        u = φ / (2 * pi) * input_.size[0]
        v = θ / pi * input_.size[1]
        o[s + z, s - 1 - y] = i[u, v]
output.save('NegativeX.jpg')

# +Y
for z in range(-s, s):
    for x in range(-s, s):
        y = +s
        φ = atan2(x, z)
        θ = atan2(hypot(z, x), y)
        u = φ / (2 * pi) * input_.size[0]
        v = θ / pi * input_.size[1]
        o[s - 1 - z, s + x] = i[u, v]
output.save('PositiveY.jpg')

# -Y
for z in range(-s, s):
    for x in range(-s, s):
        y = -s
        φ = atan2(x, z)
        θ = atan2(hypot(z, x), y) - 1e-9
        u = φ / (2 * pi) * input_.size[0]
        v = θ / pi * input_.size[1]
        o[s - 1 - z, s - 1 - x] = i[u, v]
output.save('NegativeY.jpg')

# +Z
for x in range(-s, s):
    for y in range(-s, s):
        z = s
        φ = atan2(z, x)
        θ = atan2(hypot(z, x), y)
        u = φ / (2 * pi) * input_.size[0]
        v = θ / pi * input_.size[1]
        o[s - 1 - x, s - 1 - y] = i[u, v]
output.save('PositiveZ.jpg')

# -Z
for x in range(-s, s):
    for y in range(-s, s):
        z = -s
        φ = atan2(z, x)
        θ = atan2(hypot(z, x), y)
        u = φ / (2 * pi) * input_.size[0]
        v = θ / pi * input_.size[1]
        o[s + x, s - 1 - y] = i[u, v]
output.save('NegativeZ.jpg')
